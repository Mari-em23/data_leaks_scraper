import io, asyncio, os, re
from telethon import TelegramClient
from dotenv import load_dotenv
from googletrans import Translator

from Telegram.llm.llm import generate_leak_name, generate_leak_description
from sqlite_connection.sqlite_connection import add_telegram_leak, add_domain, update_last_seen, to_be_updated


load_dotenv()

# Telegram setup
api_id = os.getenv("API_ID")
api_hash = os.getenv("API_HASH")

channels = [
    "https://t.me/+Fy4IZ9YJWxIyZDRk",
    "https://t.me/firewirBackupChannel",
    "https://t.me/MOROCCANSOLDIERS2",
    "https://t.me/M0roccan_Black_CyberArmy",
    "https://t.me/TheBlackMaskers",
    

]

english_keywords = [
    "Tunisia", "Tunis", "tunisie", ".tn", "+216", "Tunisian",
  "ANCS"
]



cyberattacks_keywords = [
    "cyberattack", "cyber attack", "cyber-attacks",
    "hack", "hacked", "hacker", "hacking",
    "breach", "breached", "data breach",
    "leak", "leaks", "leaked", "leaking",
    "database", "db", "dump", "full dump",
    "credentials", "passwords", "emails", "combo list",
    "access", "unauthorized access",
    "defaced", "defacement",
    "ransomware", "malware", "exploit",
    "vulnerability", "zero-day",
    "exposed", "exposure",
    "compromised", "compromise", "for sale",
    "logs", "stealer logs",
    "admin panel", "shell access",
    "SQL injection", "XSS", "DDoS", "infiltrated", "sensitive", "data"
]

english_pattern = re.compile(
    r'(?:' + '|'.join(re.escape(k) for k in english_keywords) + r')',
    re.IGNORECASE
)

cyberattacks_pattern = re.compile(
    r'(?:' + '|'.join(re.escape(k) for k in cyberattacks_keywords) + r')',
    re.IGNORECASE
)

def contains_keyword(text):

    return bool(english_pattern.search(text) and cyberattacks_pattern.search(text)) 

# Translates text into English to ensure that all prompts provided to the LLM are in a consistent language
async def translate_text(text):
     
      async with Translator() as translator:
        result = await translator.translate(text, dest="en")
        return result.text

TN_DOMAIN_REGEX = re.compile(
    r'\b(?:[a-zA-Z0-9-]+\.)+tn\b',
    re.IGNORECASE
)

# Returns URLs ending with .tn so that they are saved in database and associated with the corresponding posts
def get_domains_mentioned(text):

    return  list(set(TN_DOMAIN_REGEX.findall(text)))


# Returns info about the post that will be stored in the database 
async def get_message_info(message, channel_url, channel_name, client, is_public):

    post_id = channel_url + "-" + str(message.id)
    text = message.raw_text
    source = f"Source : Telegram, Channel URL : {channel_url}, Message ID : {message.id}"
    message_date = (message.date).strftime("%Y-%m-%d %H:%M:%S")
    post = text + "\n sent by " + channel_name + " at " + message_date # Messages with their sender and date are given to the LLM as an input better results
    leak_name = generate_leak_name(post) 
    post_description = generate_leak_description(post)
    domains_mentioned = get_domains_mentioned(text)
    if is_public: # Only from public channels we are able to access messages via links
        message_link = f"{channel_url}/{message.id}"
    else:
        message_link = None
    
    image_bytes = None
    if message.photo:
        # Downloads FIRST image as bytes
        image_bytes_io = io.BytesIO()
        await client.download_media(message.photo, file=image_bytes_io)
        image_bytes = image_bytes_io.getvalue()

    return {
    "id": post_id,
    "channel_url": channel_url,
    "message_id": message.id,
    "leak_name": leak_name,
    "description": post_description,
    "raw_text": text,
    "link": message_link,
    "date": message_date,
    "image_bytes": image_bytes,
    "domains_mentioned": domains_mentioned
    }


"""What the main function does :
    - For each channel listed in channels list,
        - it gets the channel named and checks if it is private or public,
        - fetches recent messages until a previously processed message is reached (last seen messages table)
        - for each fetched message :
            - Verifies that the raw text of the message is not empty (media-only messages are not saved to the database),
            - translates the raw text of the message to English to facilitate the job for the LLM,
            - verifies that one or more Tunisian related keywords (Tunisia, Tunis, .tn..) AND one or more cyberattacks keyboards (hack, breach, leak..) are present in the text,
            - prepares message's related info : * id * source (Telegram, channel URL, message ID) * leak_name generated by LLM * 
            description generated by LLM *  raw_text * (message) link * date (time sent) * (first) image_bytes * domains_mentioned (.tn).
            - Prints detailed information in console.
            - The retrieved and generated info are stored in the database.
""" 
async def main():
    async with TelegramClient("Telegram/mySession", api_id, api_hash) as client:

        for channel_url in channels:
            entity = await client.get_entity(channel_url)
            channel_name = getattr(entity, "title", str(channel_url))
            is_public = getattr(entity, 'username', None) is not None
            print("Channel name: " + channel_name)
            
            async for message in client.iter_messages(channel_url, reverse=True):
                if to_be_updated(channel_url, message.id):
                    update_last_seen(channel_url, message.id)
                    if not message.raw_text:
                        continue

                    translated_text = await translate_text(message.raw_text)
                    
                    if(contains_keyword(translated_text)):
                        info = await get_message_info(message, channel_url, channel_name, client, is_public)
                        
                        print("Post name: " + info["leak_name"])
                        print(f"ID message within the channel: {message.id}")
                        print("Post description: " + info["description"])

                        if info["link"]: 
                            print("Message link for more details: " + info["link"])

                        print("Message date: " + info["date"])

                        if info["domains_mentioned"]:
                            print(f"Mentioned .tn domains : {info['domains_mentioned']}")
                            # Saves domains in database
                            for domain in info["domains_mentioned"]:
                                add_domain(domain, info["id"])

                        if info["image_bytes"]:
                            print(f"Got image bytes, size: {len(info['image_bytes'])} bytes")

                        print("-" * 60)
                        # Saves posts in database
                        add_telegram_leak(info)
                       
                    else:
                        print(f"Post with message ID {message.id} is irrelevant. Skip.")

# Runs the async main
asyncio.run(main())
